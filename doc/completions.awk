#!/usr/bin/awk -f

function load_zelta_verbs() {
	_cmd = "zelta 2>&1"
	FS = "  +"
	while (_cmd | getline) {
		if (/^  [^ ]/) {
			Verbs[$2] = tolower($3)
		}
	}
	close(_cmd)
	zelta
}

function case_zelta_help() {
	_help_exclude["help"] = 1
	_help_exclude["version"] = 1
	_lpad = "\t\t\t"
	_case_block = _case_block _lpad "(help)\n"
	_case_block = _case_block _lpad "local -a help_topics\n"
	_case_block = _case_block _lpad "help_topics=(\n"
	_lpad = _lpad "\t'"
	_rpad = "'\n"
	for (_h in Verbs) {
		if (_h in _help_exclude) continue
		_case_block = _case_block _lpad _h ":" Verbs[_h] _rpad
	}
	_lpad = "\t\t\t"
	_rpad = "\n"
	_case_block = _case_block _lpad ")" _rpad
	_case_block = _case_block _lpad "_arguments ':help topic:{_describe -t help-topics \"help topic\" help_topics}'" _rpad
	_case_block = _case_block _lpad ";;" _rpad
	return _case_block
}

function zelta_match_options(	_cmd, _opt, _descr, _match_options) {
	# load zelta match -o options, comma delimited
	_cmd = "zelta match 2>&1"
	FS = "\t|  +"
	while (_cmd | getline) {
		if (/^\t/ && $3 && ($2 != "PROPERTY")) {
			_opt = $2
			_descr = tolower($3)
			# construct comma list here bro
			# _match_options =
		}
	}
	close(_cmd)
	return _match_options
}

BEGIN {
	load_zelta_verbs()

	FS = "\t"
	
	# Zsh Completion Header
	print "#compdef zelta"
	print ""
	print "# Auto-generated by make_zelta_comp.awk"
	print "# Source this file in your .zshrc or place in fpath"
	print "_zelta() {"
	print "\tlocal context state state_descr line"
	print "\ttypeset -A opt_args"
	print ""
	print "\t_arguments -C \\"
	print "\t\t\"1:verb:->verbs\" \\"
	print "\t\t\"*::options:->options\""
	print ""
	print "\tcase $state in"
	print "\t\t(verbs)"
	print "\t\t\tlocal verbs"
	print "\t\t\tverbs=("
}

# Clean input lines of windows returns
{ sub(/\r$/, "") }

# Skip comments, empty lines, and the Header row
/^#/ || /^[[:space:]]*$/ || $1 == "VERBS" || $8 || !$7 { next }

{
	gsub(/'/, "\"")
	verbs_csv = $1
	flags_csv = $2
	key       = $3
	type      = $5
	desc      = $7
	warning   = $8

	if (!$6 && (type ~ /^(set|list|arglist)$/))
		subopt = 1
	else
		subopt = 0

print $2 > "/dev/stderr"
	# Ignore rows with no flags (config-only options)
	if (flags_csv == "" || flags_csv == "-") next

	if (warning != "") desc = desc " (" warning ")"

	# --- Construct Argument Action ---
	# Syntax: :message:action
	arg_action = ""
	
	# Heuristics for Zsh actions based on KEY name or Type
	if (subopt) {
		if (key == "CONFIG")         action = "_files"
		else                         action = "" # Default text input

		# Construct the action block
		if (action != "") arg_action = ":" key ":" action
		else              arg_action = ":" key ":"
	}

	# --- Construct Option Spec ---
	
	# Split flags
	split(flags_csv, flags, ",")
	
	# Check for repeatability
	# 'list', 'arglist', 'incr' can be repeated (*)
	is_repeat = (type ~ /^(list|arglist|incr|decr)$/)
	prefix = (is_repeat ? "\\*" : "")

	# Build Exclusion String '(-a --alias)'
	exclusion = ""
	if (!is_repeat && length(flags) > 1) {
		# Construct space-separated listing for exclusion
		ex_str = flags[1]
		for(k=2; k<=length(flags); k++) ex_str = ex_str " " flags[k]
		exclusion = "'(" ex_str ")'"
	}

	# Build Flag String
	# If aliased: {-v,--verbose} (UNQUOTED braces for zsh expansion)
	flag_str = ""
	if (length(flags) > 1) {
		flag_str = "{" flags[1]
		for(k=2; k<=length(flags); k++) flag_str = flag_str "," flags[k]
		flag_str = flag_str "}"
	} else {
		flag_str = flags[1]
	}

	# Combining it all
	# Syntax: exclusion prefix flag_str '[desc]:arg:action'
	# QUOTING: flag_str must be UNQUOTED if it contains braces {} (to allow expansion)
	# The spec part (desc+action) should be strictly quoted.
	
	spec = "[" desc "]" arg_action
	
	# Final line construction
	# \047 is single quote
	line_out = "\t\t\t\t" exclusion prefix flag_str "\047" spec "\047 \\"

	# Store in appropriate buffers
	split(verbs_csv, v_arr, ",")
	for (i in v_arr) {
		v = v_arr[i]
		if (v == "all") {
			if (global_opts == "") global_opts = line_out
			else global_opts = global_opts "\n" line_out
		} else {
			# Track unique verbs
			if (!seen[v]++) verb_list[++verb_count] = v
			
			if (verb_opts[v] == "") verb_opts[v] = line_out
			else verb_opts[v] = verb_opts[v] "\n" line_out
		}
	}
}

END {
	# Finish the "verbs" section
	# for (i = 1; i <= verb_count; i++) {
	# 	print "\t\t\t\t" verb_list[i]
	# }
	for (i in Verbs)
		print "\t\t\t\t" i ":'"Verbs[i]"'"
	print "\t\t\t)"
	print "\t\t\t_describe -t commands 'zelta verb' verbs"
	print "\t\t\t;;"
	print ""
	print "\t\t(options)"
	# This context switch is critical for subcommand args
	print "\t\t\tcase $line[1] in"
	print case_zelta_help()

	# Iterate verbs for specific options
	# for (i = 1; i <= verb_count; i++) {
	for (i in Verbs) { #print "\t\t\t\t" Verbs[i]
		# v = verb_list[i]
		v = i
		print "\t\t\t\t(" v ")"
		print "\t\t\t\t\t_arguments -s -S \\"
		
		# Print Globals
		if ((global_opts != "") && (v !~ /version|help/)) print global_opts

		# Print Verb Specifics
		if (verb_opts[v] != "") print verb_opts[v]

		# Tail Argument Logic (Context specific)  
		# This needs work and I think does nothing right now. Policy does not accept files; probably needs to be
		# data driven. zfs datasets scan need to be rewritten because the stock code is too greedy.
	    if (v ~ /^(backup|sync|replicate|match|clone|rotate|revert|snapshot)$/) {  
	      print "\t\t\t\t\t\047*:dataset:_zfs_dataset\047"  
	    } else if (v == "policy") {  
	      print "\t\t\t\t\t\047*:policy target:_files\047"  
	    } else if (v == "version") {  
			# Nothing
	    } else {  
	      print "\t\t\t\t\t\047*:args:\047"  
	    }		print "\t\t\t\t\t;;"
	}

	print "\t\t\tesac"
	print "\t\t\t;;"
	print "\tesac"
	print "}"
}
