#!/usr/bin/awk -f

BEGIN {
	FS = "\t"
	
	# Zsh Completion Header
	print "#compdef zelta"
	print ""
	print "# Auto-generated by make_zelta_comp.awk"
	print "# Source this file in your .zshrc or place in fpath"
	print "_zelta() {"
	print "\tlocal context state state_descr line"
	print "\ttypeset -A opt_args"
	print ""
	print "\t_arguments -C \\"
	print "\t\t\"1:verb:->verbs\" \\"
	print "\t\t\"*::options:->options\""
	print ""
	print "\tcase $state in"
	print "\t\t(verbs)"
	print "\t\t\tlocal verbs"
	print "\t\t\tverbs=("
}

# Clean input lines of windows returns
{ sub(/\r$/, "") }

# Skip comments, empty lines, and the Header row
/^#/ || /^[[:space:]]*$/ || $1 == "VERBS" || $8 { next }

{
	gsub(/'/, "\"")
	verbs_csv = $1
	flags_csv = $2
	key       = $3
	type      = $5
	desc      = $7
	warning   = $8

	# Ignore rows with no flags (config-only options)
	if (flags_csv == "" || flags_csv == "-") next

	if (warning != "") desc = desc " (" warning ")"

	# --- Construct Argument Action ---
	# Syntax: :message:action
	arg_action = ""
	
	# Heuristics for Zsh actions based on KEY name or Type
	if (type ~ /^(set|list|arglist)$/) {
		if (key == "CONFIG")         action = "_files"
		else if (key == "LOG_LEVEL") action = "(0 1 2 3 4)"
		else if (key == "LOG_MODE")  action = "(text json)"
		else if (key ~ /DIRECTION/)  action = "(PUSH PULL)"
		else if (key ~ /_ROOT$/)     action = "_files -/" # Directories only
		else if (key ~ /FILE$/)      action = "_files"
		else                         action = "" # Default text input

		# Construct the action block
		if (action != "") arg_action = ":" key ":" action
		else              arg_action = ":" key ":"
	}

	# --- Construct Option Spec ---
	
	# Split flags
	split(flags_csv, flags, ",")
	
	# Check for repeatability
	# 'list', 'arglist', 'incr' can be repeated (*)
	is_repeat = (type ~ /^(list|arglist|incr)$/)
	prefix = (is_repeat ? "*" : "")

	# Build Exclusion String '(-a --alias)'
	exclusion = ""
	if (!is_repeat && length(flags) > 1) {
		# Construct space-separated listing for exclusion
		ex_str = flags[1]
		for(k=2; k<=length(flags); k++) ex_str = ex_str " " flags[k]
		exclusion = "'(" ex_str ")'"
	}

	# Build Flag String
	# If aliased: {-v,--verbose} (UNQUOTED braces for zsh expansion)
	flag_str = ""
	if (length(flags) > 1) {
		flag_str = "{" flags[1]
		for(k=2; k<=length(flags); k++) flag_str = flag_str "," flags[k]
		flag_str = flag_str "}"
	} else {
		flag_str = flags[1]
	}

	# Combining it all
	# Syntax: exclusion prefix flag_str '[desc]:arg:action'
	# QUOTING: flag_str must be UNQUOTED if it contains braces {} (to allow expansion)
	# The spec part (desc+action) should be strictly quoted.
	
	spec = "[" desc "]" arg_action
	
	# Final line construction
	# \047 is single quote
	line_out = "\t\t\t\t" exclusion prefix flag_str "\047" spec "\047 \\"

	# Store in appropriate buffers
	split(verbs_csv, v_arr, ",")
	for (i in v_arr) {
		v = v_arr[i]
		if (v == "all") {
			if (global_opts == "") global_opts = line_out
			else global_opts = global_opts "\n" line_out
		} else {
			# Track unique verbs
			if (!seen[v]++) verb_list[++verb_count] = v
			
			if (verb_opts[v] == "") verb_opts[v] = line_out
			else verb_opts[v] = verb_opts[v] "\n" line_out
		}
	}
}

END {
	# Finish the "verbs" section
	for (i = 1; i <= verb_count; i++) {
		print "\t\t\t\t" verb_list[i]
	}
	print "\t\t\t)"
	print "\t\t\t_describe -t commands '\''zelta verb'\'' verbs"
	print "\t\t\t;;"
	print ""
	print "\t\t(options)"
	# This context switch is critical for subcommand args
	print "\t\t\tcase $line[1] in"

	# Iterate verbs for specific options
	for (i = 1; i <= verb_count; i++) {
		v = verb_list[i]
		print "\t\t\t\t(" v ")"
		print "\t\t\t\t\t_arguments -s -S \\"
		
		# Print Globals
		if (global_opts != "") print global_opts

		# Print Verb Specifics
		if (verb_opts[v] != "") print verb_opts[v]

		# Tail Argument Logic (Context specific)
		if (v ~ /^(backup|sync|replicate|match|clone|rotate|revert|snapshot)$/) {
			print "\t\t\t\t\t\047*:dataset:_zfs_dataset\047"
		} else if (v == "policy") {
			print "\t\t\t\t\t\047*:policy target:_files\047"
		} else {
			print "\t\t\t\t\t\047*:args:_files\047"
		}
		
		print "\t\t\t\t\t;;"
	}

	print "\t\t\tesac"
	print "\t\t\t;;"
	print "\tesac"
	print "}"
}
